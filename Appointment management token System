-- =========================================================
-- 0) Required extension
-- =========================================================
-- Install pgcrypto in the extensions schema
CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;  -- for pgcrypto.gen_random_bytes()

-- =========================================================
-- A) Columns, constraints, indexes for tokenized manage
-- =========================================================
alter table public.appointments
  add column if not exists manage_token text,
  add column if not exists manage_token_expires_at timestamptz;

create unique index if not exists appointments_manage_token_uk
on public.appointments (manage_token)
where manage_token is not null;

-- (Optional) basic shape check for hex tokens (32 hex chars)
do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'appointments_manage_token_hex_chk'
      and conrelid = 'public.appointments'::regclass
  ) then
    alter table public.appointments
      add constraint appointments_manage_token_hex_chk
      check (
        manage_token is null
        or (length(manage_token) = 32 and manage_token ~ '^[0-9a-f]+$')
      );
  end if;
end $$;

-- =========================================================
-- B) Safe search_path helper (idempotent)
-- =========================================================
create or replace function public.set_safe_search_path() returns void
language sql
as $$ select set_config('search_path','public',true); $$;

-- =========================================================
-- C) Secure random token (hex) using pgcrypto
-- =========================================================
create or replace function public._gen_manage_token()
returns text
language sql
stable
set search_path = public
as $$
  select encode(extensions.gen_random_bytes(16), 'hex');
$$;

revoke all on function public._gen_manage_token() from public;
grant execute on function public._gen_manage_token() to anon, authenticated;

-- =========================================================
-- D) Auth â†’ business mapping for RLS (security definer)
-- =========================================================
create or replace function public.get_user_businesses()
returns table(user_id uuid, business_id uuid)
language sql
stable
security definer
set search_path = public
as $$
  select bu.user_id, bu.business_id
  from public.business_users bu
  where bu.user_id = auth.uid();
$$;

revoke all on function public.get_user_businesses() from public;
grant execute on function public.get_user_businesses() to authenticated;

-- =========================================================
-- E) Issue (or return existing) manage token for an appt
-- =========================================================
create or replace function public.issue_manage_token(p_appointment_id uuid)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  v_tok  text;
  v_rows int := 0;
begin
  perform set_safe_search_path();

  select a.manage_token into v_tok
  from public.appointments a
  where a.id = p_appointment_id;

  if v_tok is null then
    v_tok := public._gen_manage_token();

    update public.appointments a
       set manage_token = v_tok,
           manage_token_expires_at = coalesce(a.manage_token_expires_at, now() + interval '365 days')
     where a.id = p_appointment_id;

    get diagnostics v_rows = row_count;
    if v_rows <> 1 then
      raise exception 'Failed to issue manage token (appointment not found or multiple rows matched)';
    end if;
  end if;

  return v_tok;
end; $$;

revoke all on function public.issue_manage_token(uuid) from public;
grant execute on function public.issue_manage_token(uuid) to anon, authenticated;

-- =========================================================
-- F) Confirm booking (patched to safely set token)
--    Returns TRUE only if exactly one pending hold was confirmed
-- =========================================================
create or replace function public.confirm_booking_public(
  p_appointment_id uuid,
  p_stripe_payment_intent text default null,
  p_deposit_cents int default 0
)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_rows int := 0;
begin
  perform set_safe_search_path();

  if p_deposit_cents is not null and p_deposit_cents < 0 then
    raise exception 'Deposit amount cannot be negative';
  end if;

  update public.appointments a
     set status = 'confirmed',
         hold_expires_at = null,
         stripe_payment_intent = coalesce(p_stripe_payment_intent, a.stripe_payment_intent),
         deposit_cents = coalesce(p_deposit_cents, a.deposit_cents),
         manage_token = coalesce(a.manage_token, public._gen_manage_token()),
         manage_token_expires_at = coalesce(a.manage_token_expires_at, now() + interval '365 days')
   where a.id = p_appointment_id
     and a.status = 'pending'
     and (a.hold_expires_at is null or a.hold_expires_at > now());

  get diagnostics v_rows = row_count;
  return v_rows = 1;
end; $$;

revoke all on function public.confirm_booking_public(uuid, text, int) from public;
grant execute on function public.confirm_booking_public(uuid, text, int) to anon, authenticated;

-- =========================================================
-- G) Fetch appointment summary by token (read-only)
-- =========================================================
create or replace function public.get_appointment_by_token(p_token text)
returns table(
  appointment_id uuid,
  business_slug text,
  business_name text,
  service_name text,
  staff_name text,
  status public.appointment_status,
  start_ts timestamptz,
  end_ts timestamptz,
  timezone text
)
language plpgsql
security definer
set search_path = public
as $$
begin
  perform set_safe_search_path();

  return query
  select
    a.id         as appointment_id,
    b.slug       as business_slug,
    b.name       as business_name,
    s.name       as service_name,
    st.name      as staff_name,
    a.status,
    a.start_ts,
    a.end_ts,
    b.timezone
  from public.appointments a
  join public.businesses b on b.id = a.business_id
  join public.services   s on s.id = a.service_id
  join public.staff      st on st.id = a.staff_id
  where a.manage_token = p_token
    and (a.manage_token_expires_at is null or a.manage_token_expires_at > now())
  limit 1;
end; $$;

revoke all on function public.get_appointment_by_token(text) from public;
grant execute on function public.get_appointment_by_token(text) to anon, authenticated;

-- =========================================================
-- H) Reschedule by token (same staff/service) with row lock
-- =========================================================
create or replace function public.reschedule_appointment_by_token(
  p_token text,
  p_new_start_ts timestamptz
)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_appt_id     uuid;
  v_business_id uuid;
  v_service_id  uuid;
  v_staff_id    uuid;
  v_status      public.appointment_status;
  v_dur         int;
  v_buf_before  int;
  v_buf_after   int;
  v_total       int;
  v_new_end     timestamptz;
  v_rows        int := 0;
begin
  perform set_safe_search_path();

  if p_new_start_ts < now() then
    raise exception 'Cannot reschedule to a past time';
  end if;

  -- Lock the current appointment row to avoid race conditions
  select a.id, a.business_id, a.service_id, a.staff_id, a.status,
         s.duration_minutes, s.buffer_before_minutes, s.buffer_after_minutes
    into v_appt_id, v_business_id, v_service_id, v_staff_id, v_status,
         v_dur, v_buf_before, v_buf_after
  from public.appointments a
  join public.services s on s.id = a.service_id
  where a.manage_token = p_token
    and (a.manage_token_expires_at is null or a.manage_token_expires_at > now())
  for update of a;

  if v_appt_id is null then
    raise exception 'Invalid or expired token';
  end if;

  if v_status not in ('confirmed','reconfirm_pending') then
    raise exception 'Only confirmed or reconfirm-pending appointments can be rescheduled';
  end if;

  v_total := coalesce(v_dur,0) + coalesce(v_buf_before,0) + coalesce(v_buf_after,0);
  if v_total <= 0 then
    raise exception 'Invalid service duration or buffers';
  end if;

  v_new_end := p_new_start_ts + make_interval(mins => v_total);

  -- Staff time off check
  if exists (
    select 1 from public.staff_time_off toff
    where toff.staff_id = v_staff_id
      and tstzrange(toff.start_ts, toff.end_ts, '[)') &&
          tstzrange(p_new_start_ts, v_new_end, '[)')
  ) then
    raise exception 'Staff unavailable at that time';
  end if;

  -- Conflict check (other appointments)
  if exists (
    select 1 from public.appointments a2
    where a2.business_id = v_business_id
      and a2.staff_id = v_staff_id
      and a2.id <> v_appt_id
      and a2.status in ('pending','confirmed','reconfirm_pending')
      and coalesce(a2.hold_expires_at, now() + interval '100 years') > now()
      and a2.time_range && tstzrange(p_new_start_ts, v_new_end, '[)')
  ) then
    raise exception 'Selected time overlaps with another booking';
  end if;

  update public.appointments a
     set start_ts = p_new_start_ts,
         end_ts   = v_new_end,
         status   = 'confirmed'
   where a.id = v_appt_id;

  get diagnostics v_rows = row_count;
  return v_rows = 1;
end; $$;

revoke all on function public.reschedule_appointment_by_token(text, timestamptz) from public;
grant execute on function public.reschedule_appointment_by_token(text, timestamptz) to anon, authenticated;

-- =========================================================
-- I) Cancel by token (with optional reason)
-- =========================================================
create or replace function public.cancel_appointment_by_token(
  p_token text,
  p_reason text default null
)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_appt_id uuid;
  v_status  public.appointment_status;
  v_rows    int := 0;
begin
  perform set_safe_search_path();

  select a.id, a.status into v_appt_id, v_status
  from public.appointments a
  where a.manage_token = p_token
    and (a.manage_token_expires_at is null or a.manage_token_expires_at > now())
  limit 1;

  if v_appt_id is null then
    raise exception 'Invalid or expired token';
  end if;

  if v_status not in ('pending','confirmed','reconfirm_pending') then
    raise exception 'Only pending/confirmed appointments can be cancelled';
  end if;

  update public.appointments a
     set status = 'cancelled',
         notes  = case
                    when p_reason is not null
                      then coalesce(a.notes,'') || E'\n[Client cancel] ' || p_reason
                    else a.notes
                  end
   where a.id = v_appt_id;

  get diagnostics v_rows = row_count;
  return v_rows = 1;
end; $$;

revoke all on function public.cancel_appointment_by_token(text, text) from public;
grant execute on function public.cancel_appointment_by_token(text, text) to anon, authenticated;
